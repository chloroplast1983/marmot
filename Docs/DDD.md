# DDD 构建思路

---

### 简介

我们使用`DDD`的目的是希望我们的代码和产品人员能有共同的`领域语言`,随着领域的划分也更有益于划分我们微服务的`边界`.

这里我们需要关注两个点:

* `领域语言`
* `领域边界`

`领域语言`是方便于我们和产品沟通的一个良好渠道,我们不希望我们的代码是冷冰冰没有思想的,我们按照产品的需求开发代码,如果我们的代码拥有`良好可读性`(具体参见代码可读性的艺术,代码整洁之道)配合和产品一样思路的`领域`概念开发.我们可以提炼出良好的`领域语言`.

不要把代码关注于面向数据库开发,那样你的代码里面的逻辑只有`增删查改`,而缺少现实生活中的业务逻辑.

### 场景

我们先构建一个假象的简单的产品需求场景出来:

产品人员告诉我们:

		我们的项目需要用户,用户首先可以简单的使用手机号,在收到手机验证码的时候就填写密码就可以轻易的完成注册.用户注册成功后需要自动登录,用户在退出后可以再次输入手机号和密码并且正确输入图片验证码进行登录.
		
		哦,对了 用户成功登陆后可以自己修改密码.如果用户忘了密码不能登陆他们还能通过手机验证码校验进行重置密码.


#### 区分名词和动词

**名词**

* 手机号
* 密码
* 重复密码
* 手机验证码
* 图片验证码
* 用户名(未提及,但是估计以后扩展我们需要扩展该字段)

**动词**

* 注册
* 发送手机短信(验证码),这个动作需要放在其他微服务里面处理,这个部分的demo代码只包含了用户部分.

这里我没有把登陆放入都动词里面,因为它本质是一个查询的过程不涉及任何插入和更新的动作.但是我在定义接口的时候使用`POST`接口,从含义上表明这不是一个简单的查询,因为后面可能会有一些扩展需要做一些数据插入的操作.

#### 前后分离的思考

**一些需求**

* 注册完成后需要自动登陆
* 验证手机验证码
* 验证图片验证码


首先我们提炼纯粹的注册功能,就是把用户的信息录入到我们的服务内,手机短信验证是一个前端服务层的`业务逻辑规则`,因为我们假设以后我们的管理后台有一个录入用户的功能,是不是就不需要手机短信验证?

注册时候的重复密码也是前端的业务逻辑判断(并不是所有的注册功能都需要输入密码和重复密码,例如很多网站提供的快速注册功能)

图片验证码也是一个前端服务层的业务逻辑,有的网站是在第一次登陆失败后才填写验证码.

所以我们在关注后端服务构建的时候只关注纯粹的服务功能,不要考虑任何前端领域的业务逻辑.

#### 开始开发后端服务

我们根据`名词`整理用户的属性,`动词`整理`命令`.

**模型的属性**

所有我们可以得出用户的属性有:

* id (实体必须包含)
* 手机号 (唯一)
* 用户名 (唯一,但是使用待定)
* 密码
* 盐(加密密码的杂质,这个是根据我们使用的加密规则产生的)
* 创建时间(扩展预留字段)
* 最后更新时间(扩展预留字段)
* 状态(扩展预留字段)
* 最后状态更新时间(扩展预留字段)

**命令**

扩展我们的命令:

* 注册  (`SingUpCommand`)
	* 手机号
	* 密码
	* id,内置字段用户注册后回填使用(这里可以理解为你交付一个公务人员办理一张申请表单,这是发出一个命令.他处理成功后会告诉你,你的业务已经受理,受理号为xxxx).
* 更新密码 (`UpdatePasswordCommand`)
	* id
	* 密码
* 重置密码 (`RestPasswordCommand`)
	* 手机号
	* 密码
	* id,处理成功后回填,这里只是方便我们使用而处理的字段.
	
**领域对象的方法**

从上面看见我们虽然有`更新密码`和`重置密码`两个命令,但是它们的本质不就是修改一个用户的密码吗?这个只是对用户(使用我们接口的人)来说有2个功能而已,因为使用`重置密码`的原因是我们不知道用户的id(唯一标示).

所以我们封装领域对象的方法是:

* `signUp()`注册
* `updatePassword()`修改密码

我们需要在这里使用`命令处理器`把`命令`和`领域对象`一起封装起来,也就是我们的目标是我们对外给用户(接口使用者)呈现的是命令,队内封装到某一个`领域对象(或者领域服务)`具体的业务逻辑.

什么时候使用`领域服务`呢? 当我们需要在领域服务中调用多个领域对象协同处理一个工作的时候就需要领域服务.因为有的时候一个业务一个领域对象即可处理,但有的时候需要协同多个领域对象一起出来.这里可以抽象的理解为你去办理一个业务,这肯定不是一个人(部门)就能完成,他需要`内部的`(对外不可见,作为当事人不知道)调度多个人(部门)一起处理.但是对于用户来说他只能理解这是一个xxx业务.

**数据库设计**

当我们设计完所有业务逻辑相关的概念的时候,我们在根据需求设计数据库.这里就不一一概述了,这里主要就是先考虑好的你对象在考虑数据库设计.不要让数据库设计约束了你的思维.

**设计view层的jsonapSchema和view**

这里使用的是第三方的[jsonapi的扩展](https://github.com/neomerx/json-api/ "jsonapi 扩展")

**设计路由**

路由使用的也是一个第三方扩展[fastroute](https://github.com/nikic/FastRoute "fastroute")

其实主要就是使用该扩展实现我们的`REST`语义

* POST
	* 非幂等
	* 不安全
* PUT
	* 幂等
	* 不安全
* GET
	* 安全
	* 幂等
* DELETE
	* 幂等
	* 不安全
	
尽量用语义的形式来设计接口,具体可以参考一些`REST`的设计思想.

#### 测试

现在我们只是引进了`Unit`单元测试.没有引进更多的测试种类.比如`api`接口测试,用户驱动测试等等.单元测试需要借鉴[phpunt](http://phpunit.de/ "phpunit")

每一个文件需要对应一个测试文件(理论上).